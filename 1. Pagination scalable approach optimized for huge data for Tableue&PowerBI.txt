a pagination approach optimized for huge data, e.g.,

Seek-based pagination TVF

Cached counts table & function

Stored procedure with progressive fetch

a robust approach to handle pagination efficiently for huge tables with:

Seek-based pagination (better than OFFSET for large data)

Cached total row count to avoid expensive COUNT(*)

A TVF for paged data

A table and function for cached counts

Step 1: Create a Cache Table for Counts
sql
Copy
Edit
CREATE TABLE dbo.PaginationCache
(
    CacheKey NVARCHAR(100) PRIMARY KEY,  -- e.g. 'YourBigTable'
    TotalRows BIGINT,
    LastUpdated DATETIME DEFAULT GETDATE()
);

Step 2: Populate / Refresh Cache (Run periodically via SQL Agent or trigger)
sql
Copy
Edit
-- For YourBigTable
MERGE dbo.PaginationCache AS target
USING (SELECT 'YourBigTable' AS CacheKey, COUNT(*) AS TotalRows) AS source
ON target.CacheKey = source.CacheKey
WHEN MATCHED THEN
    UPDATE SET TotalRows = source.TotalRows, LastUpdated = GETDATE()
WHEN NOT MATCHED THEN
    INSERT (CacheKey, TotalRows) VALUES (source.CacheKey, source.TotalRows);
Step 3: Function to Get Cached Count and Pages
sql
Copy
Edit
CREATE FUNCTION dbo.fn_GetCachedPaginationInfo
(
    @PageSize INT,
    @CacheKey NVARCHAR(100)
)
RETURNS TABLE
AS
RETURN
(
    SELECT 
        TotalRows,
        CEILING(CAST(TotalRows AS FLOAT) / @PageSize) AS TotalPages,
        LastUpdated
    FROM dbo.PaginationCache
    WHERE CacheKey = @CacheKey
);
Step 4: Seek-Based Pagination TVF
This assumes a numeric or datetime unique sortable column, e.g., ID.

sql
Copy
Edit
CREATE FUNCTION dbo.fn_SeekPaginatedData
(
    @LastId INT = NULL,      -- ID of last record from previous page, NULL = first page
    @PageSize INT = 100
)
RETURNS TABLE
AS
RETURN
(
    SELECT TOP(@PageSize) *
    FROM YourBigTable
    WHERE (@LastId IS NULL OR ID > @LastId)
    ORDER BY ID
);
How to Use Together
First call fn_SeekPaginatedData with @LastId = NULL to get first page.

Each subsequent call uses the last ID value from previous page as @LastId.

Get total pages by calling fn_GetCachedPaginationInfo(100, 'YourBigTable') once or periodically.

Why This Works Well for Millions of Rows
No OFFSET — SQL Server doesn’t have to skip millions of rows.

Paging is done by “seek” using the indexed column ID.

Total count reads from cached table, not scanning full data.

Cache updated on a schedule (e.g., every 10 minutes or nightly).

✅ Components Summary
Feature	Implementation
Paginated data retrieval	Seek-based TVF
Total rows/pages info	Cached in a refreshable table
Cache refresh automation	Via SQL Agent or procedure
Filtered pagination support	Optional params in TVF
Non-numeric keys support	Handled via adaptable seek logic

1️⃣ Cache Table for Row Counts
sql
Copy
Edit
CREATE TABLE dbo.PaginationCache
(
    CacheKey NVARCHAR(100) PRIMARY KEY,  -- e.g., table name or table+filters
    TotalRows BIGINT NOT NULL,
    LastUpdated DATETIME NOT NULL DEFAULT GETDATE()
);
2️⃣ Procedure to Refresh Cached Count (with optional filters)
sql
Copy
Edit
CREATE PROCEDURE dbo.sp_RefreshPaginationCache
    @CacheKey NVARCHAR(100),
    @SourceSQL NVARCHAR(MAX)
AS
BEGIN
    SET NOCOUNT ON;

    DECLARE @SQL NVARCHAR(MAX) = '
        DECLARE @Count BIGINT;
        SELECT @Count = COUNT(*) FROM (' + @SourceSQL + ') AS T;

        MERGE dbo.PaginationCache AS target
        USING (SELECT ''' + @CacheKey + ''' AS CacheKey, @Count AS TotalRows) AS source
        ON target.CacheKey = source.CacheKey
        WHEN MATCHED THEN
            UPDATE SET TotalRows = source.TotalRows, LastUpdated = GETDATE()
        WHEN NOT MATCHED THEN
            INSERT (CacheKey, TotalRows, LastUpdated)
            VALUES (source.CacheKey, source.TotalRows, GETDATE());
    ';

    EXEC sp_executesql @SQL;
END
📌 Example call for a filtered count:

sql
Copy
Edit
EXEC dbo.sp_RefreshPaginationCache 
    @CacheKey = 'YourBigTable:Active',
    @SourceSQL = 'SELECT * FROM YourBigTable WHERE IsActive = 1';
Automate this with SQL Agent on a schedule.

3️⃣ TVF: Get Cached Pagination Info
sql
Copy
Edit
CREATE FUNCTION dbo.fn_GetCachedPaginationInfo
(
    @PageSize INT,
    @CacheKey NVARCHAR(100)
)
RETURNS TABLE
AS
RETURN
(
    SELECT 
        TotalRows,
        CEILING(CAST(TotalRows AS FLOAT) / @PageSize) AS TotalPages,
        LastUpdated
    FROM dbo.PaginationCache
    WHERE CacheKey = @CacheKey
);
4️⃣ TVF: Seek-Based Paginated Data with Optional Filters
This version works for tables with an ID (or any sortable) key, and supports filters.

sql
Copy
Edit
CREATE FUNCTION dbo.fn_SeekPaginatedData_Filtered
(
    @LastID INT = NULL,
    @PageSize INT = 100,
    @IsActive BIT = NULL  -- Optional filter
)
RETURNS TABLE
AS
RETURN
(
    SELECT TOP (@PageSize) *
    FROM YourBigTable
    WHERE 
        (@LastID IS NULL OR ID > @LastID)
        AND (@IsActive IS NULL OR IsActive = @IsActive)
    ORDER BY ID
);
5️⃣ Adapting for Non-Numeric Keys (e.g., GUIDs or Dates)
You can change the @LastID to @LastKey UNIQUEIDENTIFIER or @LastDate DATETIME:

sql
Copy
Edit
-- GUID example
CREATE FUNCTION dbo.fn_SeekPaginated_GUID
(
    @LastKey UNIQUEIDENTIFIER = NULL,
    @PageSize INT = 100
)
RETURNS TABLE
AS
RETURN
(
    SELECT TOP (@PageSize) *
    FROM YourTable
    WHERE (@LastKey IS NULL OR GuidKey > @LastKey)
    ORDER BY GuidKey
);
Same logic applies to composite keys (e.g., ID + Date) — just extend the WHERE clause accordingly.

🔁 Putting It Together in Client (Tableau, App, etc.)
Call dbo.fn_SeekPaginatedData_Filtered(...) with current @LastID and filters.

Optionally call dbo.fn_GetCachedPaginationInfo(...) once to show total pages.

sp_RefreshPaginationCache runs on a schedule to keep count fresh.

✅ Benefits
Extremely efficient for massive tables (no OFFSET/FETCH)

Flexible filterable pagination

Pre-computed row counts prevent query spikes

Works with apps, Tableau, Power BI, .NET, etc.

Would you like:

A version for composite keys?

A wrapper view or stored procedure for easier Tableau use?

A sample SQL Agent job definition to refresh the cache?

Let me know and I’ll build that too.

Perfect — here's the complete scalable pagination framework, with everything you asked for:

✅ 1. Cache Table for Total Rows
sql
Copy
Edit
CREATE TABLE dbo.PaginationCache
(
    CacheKey NVARCHAR(100) PRIMARY KEY,      -- e.g. 'YourTable:Filter1'
    TotalRows BIGINT NOT NULL,
    LastUpdated DATETIME NOT NULL DEFAULT GETDATE()
);
✅ 2. Stored Procedure: Refresh Cached Count (Supports Filters)
sql
Copy
Edit
CREATE PROCEDURE dbo.sp_RefreshPaginationCache
    @CacheKey NVARCHAR(100),
    @SourceSQL NVARCHAR(MAX)
AS
BEGIN
    SET NOCOUNT ON;

    DECLARE @SQL NVARCHAR(MAX) = '
        DECLARE @Count BIGINT;
        SELECT @Count = COUNT(*) FROM (' + @SourceSQL + ') AS T;

        MERGE dbo.PaginationCache AS target
        USING (SELECT ''' + @CacheKey + ''' AS CacheKey, @Count AS TotalRows) AS source
        ON target.CacheKey = source.CacheKey
        WHEN MATCHED THEN
            UPDATE SET TotalRows = source.TotalRows, LastUpdated = GETDATE()
        WHEN NOT MATCHED THEN
            INSERT (CacheKey, TotalRows, LastUpdated)
            VALUES (source.CacheKey, source.TotalRows, GETDATE());
    ';

    EXEC sp_executesql @SQL;
END
🧪 Example call:

sql
Copy
Edit
EXEC dbo.sp_RefreshPaginationCache 
    @CacheKey = 'YourBigTable:IsActive=1',
    @SourceSQL = 'SELECT * FROM YourBigTable WHERE IsActive = 1';
✅ 3. TVF: Get Cached Row Count & Total Pages
sql
Copy
Edit
CREATE FUNCTION dbo.fn_GetCachedPaginationInfo
(
    @PageSize INT,
    @CacheKey NVARCHAR(100)
)
RETURNS TABLE
AS
RETURN
(
    SELECT 
        TotalRows,
        CEILING(CAST(TotalRows AS FLOAT) / @PageSize) AS TotalPages,
        LastUpdated
    FROM dbo.PaginationCache
    WHERE CacheKey = @CacheKey
);
✅ 4. TVF: Seek-Based Pagination (with Filter)
sql
Copy
Edit
CREATE FUNCTION dbo.fn_SeekPaginatedData_Filtered
(
    @LastID INT = NULL,
    @PageSize INT = 100,
    @IsActive BIT = NULL
)
RETURNS TABLE
AS
RETURN
(
    SELECT TOP (@PageSize) *
    FROM YourBigTable
    WHERE 
        (@LastID IS NULL OR ID > @LastID)
        AND (@IsActive IS NULL OR IsActive = @IsActive)
    ORDER BY ID
);
✅ 5. TVF: Seek Pagination with Composite Key (e.g. ID + Date)
sql
Copy
Edit
CREATE FUNCTION dbo.fn_SeekPaginatedData_Composite
(
    @LastID INT = NULL,
    @LastDate DATETIME = NULL,
    @PageSize INT = 100
)
RETURNS TABLE
AS
RETURN
(
    SELECT TOP (@PageSize) *
    FROM YourBigTable
    WHERE 
        (
            @LastID IS NULL 
            OR (DateColumn > @LastDate)
            OR (DateColumn = @LastDate AND ID > @LastID)
        )
    ORDER BY DateColumn, ID
);
Ensure (DateColumn, ID) is indexed.

✅ 6. TVF: Seek-Based Pagination with GUID Key
sql
Copy
Edit
CREATE FUNCTION dbo.fn_SeekPaginated_GUID
(
    @LastKey UNIQUEIDENTIFIER = NULL,
    @PageSize INT = 100
)
RETURNS TABLE
AS
RETURN
(
    SELECT TOP (@PageSize) *
    FROM YourBigTable
    WHERE (@LastKey IS NULL OR GuidKey > @LastKey)
    ORDER BY GuidKey
);
✅ 7. Wrapper View for Tableau Use
For Tableau or clients that can't call functions with parameters directly:

sql
Copy
Edit
CREATE VIEW vw_YourBigTable_Page1
AS
SELECT *
FROM dbo.fn_SeekPaginatedData_Filtered(NULL, 100, 1);
You can dynamically generate views for fixed pages or let Tableau pass parameters via a custom SQL query.

✅ 8. SQL Agent Job Example: Auto-Refresh Count Cache
You can automate this via SQL Server Agent:

Job Step: T-SQL
sql
Copy
Edit
EXEC dbo.sp_RefreshPaginationCache 
    @CacheKey = 'YourBigTable:IsActive=1',
    @SourceSQL = 'SELECT * FROM YourBigTable WHERE IsActive = 1';
Schedule it every 5, 10, or 60 minutes based on data change volume.

📦 Summary of What You Have Now
Component	Purpose
PaginationCache	Stores precomputed total rows
sp_RefreshPaginationCache	Fills/refreshes the cache
fn_GetCachedPaginationInfo	Reads total rows and pages
fn_SeekPaginatedData_Filtered	Fetches current page efficiently
fn_SeekPaginated_GUID / Composite	Support for other key types
vw_YourBigTable_Page1	Tableau or static usage
SQL Agent Job	Keeps cache fresh







