a pagination approach optimized for huge data, e.g.,

Seek-based pagination TVF

Cached counts table & function

Stored procedure with progressive fetch

a robust approach to handle pagination efficiently for huge tables with:

Seek-based pagination (better than OFFSET for large data)

Cached total row count to avoid expensive COUNT(*)

A TVF for paged data

A table and function for cached counts

Step 1: Create a Cache Table for Counts
sql
Copy
Edit
CREATE TABLE dbo.PaginationCache
(
    CacheKey NVARCHAR(100) PRIMARY KEY,  -- e.g. 'YourBigTable'
    TotalRows BIGINT,
    LastUpdated DATETIME DEFAULT GETDATE()
);

Step 2: Populate / Refresh Cache (Run periodically via SQL Agent or trigger)
sql
Copy
Edit
-- For YourBigTable
MERGE dbo.PaginationCache AS target
USING (SELECT 'YourBigTable' AS CacheKey, COUNT(*) AS TotalRows) AS source
ON target.CacheKey = source.CacheKey
WHEN MATCHED THEN
    UPDATE SET TotalRows = source.TotalRows, LastUpdated = GETDATE()
WHEN NOT MATCHED THEN
    INSERT (CacheKey, TotalRows) VALUES (source.CacheKey, source.TotalRows);
Step 3: Function to Get Cached Count and Pages
sql
Copy
Edit
CREATE FUNCTION dbo.fn_GetCachedPaginationInfo
(
    @PageSize INT,
    @CacheKey NVARCHAR(100)
)
RETURNS TABLE
AS
RETURN
(
    SELECT 
        TotalRows,
        CEILING(CAST(TotalRows AS FLOAT) / @PageSize) AS TotalPages,
        LastUpdated
    FROM dbo.PaginationCache
    WHERE CacheKey = @CacheKey
);
Step 4: Seek-Based Pagination TVF
This assumes a numeric or datetime unique sortable column, e.g., ID.

sql
Copy
Edit
CREATE FUNCTION dbo.fn_SeekPaginatedData
(
    @LastId INT = NULL,      -- ID of last record from previous page, NULL = first page
    @PageSize INT = 100
)
RETURNS TABLE
AS
RETURN
(
    SELECT TOP(@PageSize) *
    FROM YourBigTable
    WHERE (@LastId IS NULL OR ID > @LastId)
    ORDER BY ID
);
How to Use Together
First call fn_SeekPaginatedData with @LastId = NULL to get first page.

Each subsequent call uses the last ID value from previous page as @LastId.

Get total pages by calling fn_GetCachedPaginationInfo(100, 'YourBigTable') once or periodically.

Why This Works Well for Millions of Rows
No OFFSET â€” SQL Server doesnâ€™t have to skip millions of rows.

Paging is done by â€œseekâ€ using the indexed column ID.

Total count reads from cached table, not scanning full data.

Cache updated on a schedule (e.g., every 10 minutes or nightly).

âœ… Components Summary
Feature	Implementation
Paginated data retrieval	Seek-based TVF
Total rows/pages info	Cached in a refreshable table
Cache refresh automation	Via SQL Agent or procedure
Filtered pagination support	Optional params in TVF
Non-numeric keys support	Handled via adaptable seek logic

1ï¸âƒ£ Cache Table for Row Counts
sql
Copy
Edit
CREATE TABLE dbo.PaginationCache
(
    CacheKey NVARCHAR(100) PRIMARY KEY,  -- e.g., table name or table+filters
    TotalRows BIGINT NOT NULL,
    LastUpdated DATETIME NOT NULL DEFAULT GETDATE()
);
2ï¸âƒ£ Procedure to Refresh Cached Count (with optional filters)
sql
Copy
Edit
CREATE PROCEDURE dbo.sp_RefreshPaginationCache
    @CacheKey NVARCHAR(100),
    @SourceSQL NVARCHAR(MAX)
AS
BEGIN
    SET NOCOUNT ON;

    DECLARE @SQL NVARCHAR(MAX) = '
        DECLARE @Count BIGINT;
        SELECT @Count = COUNT(*) FROM (' + @SourceSQL + ') AS T;

        MERGE dbo.PaginationCache AS target
        USING (SELECT ''' + @CacheKey + ''' AS CacheKey, @Count AS TotalRows) AS source
        ON target.CacheKey = source.CacheKey
        WHEN MATCHED THEN
            UPDATE SET TotalRows = source.TotalRows, LastUpdated = GETDATE()
        WHEN NOT MATCHED THEN
            INSERT (CacheKey, TotalRows, LastUpdated)
            VALUES (source.CacheKey, source.TotalRows, GETDATE());
    ';

    EXEC sp_executesql @SQL;
END
ðŸ“Œ Example call for a filtered count:

sql
Copy
Edit
EXEC dbo.sp_RefreshPaginationCache 
    @CacheKey = 'YourBigTable:Active',
    @SourceSQL = 'SELECT * FROM YourBigTable WHERE IsActive = 1';
Automate this with SQL Agent on a schedule.

3ï¸âƒ£ TVF: Get Cached Pagination Info
sql
Copy
Edit
CREATE FUNCTION dbo.fn_GetCachedPaginationInfo
(
    @PageSize INT,
    @CacheKey NVARCHAR(100)
)
RETURNS TABLE
AS
RETURN
(
    SELECT 
        TotalRows,
        CEILING(CAST(TotalRows AS FLOAT) / @PageSize) AS TotalPages,
        LastUpdated
    FROM dbo.PaginationCache
    WHERE CacheKey = @CacheKey
);
4ï¸âƒ£ TVF: Seek-Based Paginated Data with Optional Filters
This version works for tables with an ID (or any sortable) key, and supports filters.

sql
Copy
Edit
CREATE FUNCTION dbo.fn_SeekPaginatedData_Filtered
(
    @LastID INT = NULL,
    @PageSize INT = 100,
    @IsActive BIT = NULL  -- Optional filter
)
RETURNS TABLE
AS
RETURN
(
    SELECT TOP (@PageSize) *
    FROM YourBigTable
    WHERE 
        (@LastID IS NULL OR ID > @LastID)
        AND (@IsActive IS NULL OR IsActive = @IsActive)
    ORDER BY ID
);
5ï¸âƒ£ Adapting for Non-Numeric Keys (e.g., GUIDs or Dates)
You can change the @LastID to @LastKey UNIQUEIDENTIFIER or @LastDate DATETIME:

sql
Copy
Edit
-- GUID example
CREATE FUNCTION dbo.fn_SeekPaginated_GUID
(
    @LastKey UNIQUEIDENTIFIER = NULL,
    @PageSize INT = 100
)
RETURNS TABLE
AS
RETURN
(
    SELECT TOP (@PageSize) *
    FROM YourTable
    WHERE (@LastKey IS NULL OR GuidKey > @LastKey)
    ORDER BY GuidKey
);
Same logic applies to composite keys (e.g., ID + Date) â€” just extend the WHERE clause accordingly.

ðŸ” Putting It Together in Client (Tableau, App, etc.)
Call dbo.fn_SeekPaginatedData_Filtered(...) with current @LastID and filters.

Optionally call dbo.fn_GetCachedPaginationInfo(...) once to show total pages.

sp_RefreshPaginationCache runs on a schedule to keep count fresh.

âœ… Benefits
Extremely efficient for massive tables (no OFFSET/FETCH)

Flexible filterable pagination

Pre-computed row counts prevent query spikes

Works with apps, Tableau, Power BI, .NET, etc.

Would you like:

A version for composite keys?

A wrapper view or stored procedure for easier Tableau use?

A sample SQL Agent job definition to refresh the cache?

Let me know and Iâ€™ll build that too.

Perfect â€” here's the complete scalable pagination framework, with everything you asked for:

âœ… 1. Cache Table for Total Rows
sql
Copy
Edit
CREATE TABLE dbo.PaginationCache
(
    CacheKey NVARCHAR(100) PRIMARY KEY,      -- e.g. 'YourTable:Filter1'
    TotalRows BIGINT NOT NULL,
    LastUpdated DATETIME NOT NULL DEFAULT GETDATE()
);
âœ… 2. Stored Procedure: Refresh Cached Count (Supports Filters)
sql
Copy
Edit
CREATE PROCEDURE dbo.sp_RefreshPaginationCache
    @CacheKey NVARCHAR(100),
    @SourceSQL NVARCHAR(MAX)
AS
BEGIN
    SET NOCOUNT ON;

    DECLARE @SQL NVARCHAR(MAX) = '
        DECLARE @Count BIGINT;
        SELECT @Count = COUNT(*) FROM (' + @SourceSQL + ') AS T;

        MERGE dbo.PaginationCache AS target
        USING (SELECT ''' + @CacheKey + ''' AS CacheKey, @Count AS TotalRows) AS source
        ON target.CacheKey = source.CacheKey
        WHEN MATCHED THEN
            UPDATE SET TotalRows = source.TotalRows, LastUpdated = GETDATE()
        WHEN NOT MATCHED THEN
            INSERT (CacheKey, TotalRows, LastUpdated)
            VALUES (source.CacheKey, source.TotalRows, GETDATE());
    ';

    EXEC sp_executesql @SQL;
END
ðŸ§ª Example call:

sql
Copy
Edit
EXEC dbo.sp_RefreshPaginationCache 
    @CacheKey = 'YourBigTable:IsActive=1',
    @SourceSQL = 'SELECT * FROM YourBigTable WHERE IsActive = 1';
âœ… 3. TVF: Get Cached Row Count & Total Pages
sql
Copy
Edit
CREATE FUNCTION dbo.fn_GetCachedPaginationInfo
(
    @PageSize INT,
    @CacheKey NVARCHAR(100)
)
RETURNS TABLE
AS
RETURN
(
    SELECT 
        TotalRows,
        CEILING(CAST(TotalRows AS FLOAT) / @PageSize) AS TotalPages,
        LastUpdated
    FROM dbo.PaginationCache
    WHERE CacheKey = @CacheKey
);
âœ… 4. TVF: Seek-Based Pagination (with Filter)
sql
Copy
Edit
CREATE FUNCTION dbo.fn_SeekPaginatedData_Filtered
(
    @LastID INT = NULL,
    @PageSize INT = 100,
    @IsActive BIT = NULL
)
RETURNS TABLE
AS
RETURN
(
    SELECT TOP (@PageSize) *
    FROM YourBigTable
    WHERE 
        (@LastID IS NULL OR ID > @LastID)
        AND (@IsActive IS NULL OR IsActive = @IsActive)
    ORDER BY ID
);
âœ… 5. TVF: Seek Pagination with Composite Key (e.g. ID + Date)
sql
Copy
Edit
CREATE FUNCTION dbo.fn_SeekPaginatedData_Composite
(
    @LastID INT = NULL,
    @LastDate DATETIME = NULL,
    @PageSize INT = 100
)
RETURNS TABLE
AS
RETURN
(
    SELECT TOP (@PageSize) *
    FROM YourBigTable
    WHERE 
        (
            @LastID IS NULL 
            OR (DateColumn > @LastDate)
            OR (DateColumn = @LastDate AND ID > @LastID)
        )
    ORDER BY DateColumn, ID
);
Ensure (DateColumn, ID) is indexed.

âœ… 6. TVF: Seek-Based Pagination with GUID Key
sql
Copy
Edit
CREATE FUNCTION dbo.fn_SeekPaginated_GUID
(
    @LastKey UNIQUEIDENTIFIER = NULL,
    @PageSize INT = 100
)
RETURNS TABLE
AS
RETURN
(
    SELECT TOP (@PageSize) *
    FROM YourBigTable
    WHERE (@LastKey IS NULL OR GuidKey > @LastKey)
    ORDER BY GuidKey
);
âœ… 7. Wrapper View for Tableau Use
For Tableau or clients that can't call functions with parameters directly:

sql
Copy
Edit
CREATE VIEW vw_YourBigTable_Page1
AS
SELECT *
FROM dbo.fn_SeekPaginatedData_Filtered(NULL, 100, 1);
You can dynamically generate views for fixed pages or let Tableau pass parameters via a custom SQL query.

âœ… 8. SQL Agent Job Example: Auto-Refresh Count Cache
You can automate this via SQL Server Agent:

Job Step: T-SQL
sql
Copy
Edit
EXEC dbo.sp_RefreshPaginationCache 
    @CacheKey = 'YourBigTable:IsActive=1',
    @SourceSQL = 'SELECT * FROM YourBigTable WHERE IsActive = 1';
Schedule it every 5, 10, or 60 minutes based on data change volume.

ðŸ“¦ Summary of What You Have Now
Component	Purpose
PaginationCache	Stores precomputed total rows
sp_RefreshPaginationCache	Fills/refreshes the cache
fn_GetCachedPaginationInfo	Reads total rows and pages
fn_SeekPaginatedData_Filtered	Fetches current page efficiently
fn_SeekPaginated_GUID / Composite	Support for other key types
vw_YourBigTable_Page1	Tableau or static usage
SQL Agent Job	Keeps cache fresh







